{"version":3,"sources":["../../../../node_modules/bippy/dist/src-CqIv1vpl.js","../../../../node_modules/same-runtime/dist/jsx-runtime.js"],"sourcesContent":["/**\n * @license bippy\n *\n * Copyright (c) Aiden Bai\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n//#region src/rdt-hook.ts\nconst version = \"0.3.28\";\nconst BIPPY_INSTRUMENTATION_STRING = `bippy-${version}`;\nconst objectDefineProperty = Object.defineProperty;\nconst objectHasOwnProperty = Object.prototype.hasOwnProperty;\nconst NO_OP = () => {};\nconst checkDCE = (fn) => {\n\ttry {\n\t\tconst code = Function.prototype.toString.call(fn);\n\t\tif (code.indexOf(\"^_^\") > -1) setTimeout(() => {\n\t\t\tthrow new Error(\"React is running in production mode, but dead code elimination has not been applied. Read how to correctly configure React for production: https://reactjs.org/link/perf-use-production-build\");\n\t\t});\n\t} catch {}\n};\nconst isRealReactDevtools = (rdtHook = getRDTHook()) => {\n\treturn \"getFiberRoots\" in rdtHook;\n};\nlet isReactRefreshOverride = false;\nlet injectFnStr = void 0;\nconst isReactRefresh = (rdtHook = getRDTHook()) => {\n\tif (isReactRefreshOverride) return true;\n\tif (typeof rdtHook.inject === \"function\") injectFnStr = rdtHook.inject.toString();\n\treturn Boolean(injectFnStr?.includes(\"(injected)\"));\n};\nconst onActiveListeners = new Set();\nconst _renderers = new Set();\nconst installRDTHook = (onActive) => {\n\tconst renderers = new Map();\n\tlet i = 0;\n\tlet rdtHook = {\n\t\tcheckDCE,\n\t\tsupportsFiber: true,\n\t\tsupportsFlight: true,\n\t\thasUnsupportedRendererAttached: false,\n\t\trenderers,\n\t\tonCommitFiberRoot: NO_OP,\n\t\tonCommitFiberUnmount: NO_OP,\n\t\tonPostCommitFiberRoot: NO_OP,\n\t\ton: NO_OP,\n\t\tinject(renderer) {\n\t\t\tconst nextID = ++i;\n\t\t\trenderers.set(nextID, renderer);\n\t\t\t_renderers.add(renderer);\n\t\t\tif (!rdtHook._instrumentationIsActive) {\n\t\t\t\trdtHook._instrumentationIsActive = true;\n\t\t\t\tonActiveListeners.forEach((listener) => listener());\n\t\t\t}\n\t\t\treturn nextID;\n\t\t},\n\t\t_instrumentationSource: BIPPY_INSTRUMENTATION_STRING,\n\t\t_instrumentationIsActive: false\n\t};\n\ttry {\n\t\tobjectDefineProperty(globalThis, \"__REACT_DEVTOOLS_GLOBAL_HOOK__\", {\n\t\t\tget() {\n\t\t\t\treturn rdtHook;\n\t\t\t},\n\t\t\tset(newHook) {\n\t\t\t\tif (newHook && typeof newHook === \"object\") {\n\t\t\t\t\tconst ourRenderers = rdtHook.renderers;\n\t\t\t\t\trdtHook = newHook;\n\t\t\t\t\tif (ourRenderers.size > 0) {\n\t\t\t\t\t\tourRenderers.forEach((renderer, id) => {\n\t\t\t\t\t\t\t_renderers.add(renderer);\n\t\t\t\t\t\t\tnewHook.renderers.set(id, renderer);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tpatchRDTHook(onActive);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true\n\t\t});\n\t\tconst originalWindowHasOwnProperty = window.hasOwnProperty;\n\t\tlet hasRanHack = false;\n\t\tobjectDefineProperty(window, \"hasOwnProperty\", {\n\t\t\tvalue: function() {\n\t\t\t\ttry {\n\t\t\t\t\tif (!hasRanHack && arguments[0] === \"__REACT_DEVTOOLS_GLOBAL_HOOK__\") {\n\t\t\t\t\t\tglobalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__ = void 0;\n\t\t\t\t\t\thasRanHack = true;\n\t\t\t\t\t\treturn -0;\n\t\t\t\t\t}\n\t\t\t\t} catch {}\n\t\t\t\treturn originalWindowHasOwnProperty.apply(this, arguments);\n\t\t\t},\n\t\t\tconfigurable: true,\n\t\t\twritable: true\n\t\t});\n\t} catch {\n\t\tpatchRDTHook(onActive);\n\t}\n\treturn rdtHook;\n};\nconst patchRDTHook = (onActive) => {\n\tif (onActive) onActiveListeners.add(onActive);\n\ttry {\n\t\tconst rdtHook = globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\t\tif (!rdtHook) return;\n\t\tif (!rdtHook._instrumentationSource) {\n\t\t\trdtHook.checkDCE = checkDCE;\n\t\t\trdtHook.supportsFiber = true;\n\t\t\trdtHook.supportsFlight = true;\n\t\t\trdtHook.hasUnsupportedRendererAttached = false;\n\t\t\trdtHook._instrumentationSource = BIPPY_INSTRUMENTATION_STRING;\n\t\t\trdtHook._instrumentationIsActive = false;\n\t\t\trdtHook.on = NO_OP;\n\t\t\tif (rdtHook.renderers.size) {\n\t\t\t\trdtHook._instrumentationIsActive = true;\n\t\t\t\tonActiveListeners.forEach((listener) => listener());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst prevInject = rdtHook.inject;\n\t\t\tif (isReactRefresh(rdtHook) && !isRealReactDevtools()) {\n\t\t\t\tisReactRefreshOverride = true;\n\t\t\t\tconst nextID = rdtHook.inject({ scheduleRefresh() {} });\n\t\t\t\tif (nextID) rdtHook._instrumentationIsActive = true;\n\t\t\t}\n\t\t\trdtHook.inject = (renderer) => {\n\t\t\t\tconst id = prevInject(renderer);\n\t\t\t\t_renderers.add(renderer);\n\t\t\t\trdtHook._instrumentationIsActive = true;\n\t\t\t\tonActiveListeners.forEach((listener) => listener());\n\t\t\t\treturn id;\n\t\t\t};\n\t\t}\n\t\tif (rdtHook.renderers.size || rdtHook._instrumentationIsActive || isReactRefresh()) onActive?.();\n\t} catch {}\n};\nconst hasRDTHook = () => {\n\treturn objectHasOwnProperty.call(globalThis, \"__REACT_DEVTOOLS_GLOBAL_HOOK__\");\n};\n/**\n* Returns the current React DevTools global hook.\n*/\nconst getRDTHook = (onActive) => {\n\tif (!hasRDTHook()) return installRDTHook(onActive);\n\tpatchRDTHook(onActive);\n\treturn globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n};\nconst isClientEnvironment = () => {\n\treturn Boolean(typeof window !== \"undefined\" && (window.document?.createElement || window.navigator?.product === \"ReactNative\"));\n};\n/**\n* Usually used purely for side effect\n*/\nconst safelyInstallRDTHook = () => {\n\ttry {\n\t\tif (isClientEnvironment()) getRDTHook();\n\t} catch {}\n};\n\n//#endregion\n//#region src/core.ts\nconst FunctionComponentTag = 0;\nconst ClassComponentTag = 1;\nconst HostRootTag = 3;\nconst HostComponentTag = 5;\nconst HostTextTag = 6;\nconst FragmentTag = 7;\nconst ContextConsumerTag = 9;\nconst ForwardRefTag = 11;\nconst SuspenseComponentTag = 13;\nconst MemoComponentTag = 14;\nconst SimpleMemoComponentTag = 15;\nconst LazyComponentTag = 16;\nconst DehydratedSuspenseComponentTag = 18;\nconst SuspenseListComponentTag = 19;\nconst OffscreenComponentTag = 22;\nconst LegacyHiddenComponentTag = 23;\nconst HostHoistableTag = 26;\nconst HostSingletonTag = 27;\nconst ActivityComponentTag = 28;\nconst ViewTransitionComponentTag = 30;\nconst CONCURRENT_MODE_NUMBER = 60111;\nconst ELEMENT_TYPE_SYMBOL_STRING = \"Symbol(react.element)\";\nconst TRANSITIONAL_ELEMENT_TYPE_SYMBOL_STRING = \"Symbol(react.transitional.element)\";\nconst CONCURRENT_MODE_SYMBOL_STRING = \"Symbol(react.concurrent_mode)\";\nconst DEPRECATED_ASYNC_MODE_SYMBOL_STRING = \"Symbol(react.async_mode)\";\nconst PerformedWork = 1;\nconst Placement = 2;\nconst Hydrating = 4096;\nconst Update = 4;\nconst Cloned = 8;\nconst ChildDeletion = 16;\nconst ContentReset = 32;\nconst Snapshot = 1024;\nconst Visibility = 8192;\nconst MutationMask = Placement | Update | ChildDeletion | ContentReset | Hydrating | Visibility | Snapshot;\n/**\n* Returns `true` if object is a React Element.\n*\n* @see https://react.dev/reference/react/isValidElement\n*/\nconst isValidElement = (element) => typeof element === \"object\" && element != null && \"$$typeof\" in element && [ELEMENT_TYPE_SYMBOL_STRING, TRANSITIONAL_ELEMENT_TYPE_SYMBOL_STRING].includes(String(element.$$typeof));\n/**\n* Returns `true` if object is a React Fiber.\n*/\nconst isValidFiber = (fiber) => typeof fiber === \"object\" && fiber != null && \"tag\" in fiber && \"stateNode\" in fiber && \"return\" in fiber && \"child\" in fiber && \"sibling\" in fiber && \"flags\" in fiber;\n/**\n* Returns `true` if fiber is a host fiber. Host fibers are DOM nodes in react-dom, `View` in react-native, etc.\n*\n* @see https://reactnative.dev/architecture/glossary#host-view-tree-and-host-view\n*/\nconst isHostFiber = (fiber) => {\n\tswitch (fiber.tag) {\n\t\tcase HostComponentTag:\n\t\tcase HostHoistableTag:\n\t\tcase HostSingletonTag: return true;\n\t\tdefault: return typeof fiber.type === \"string\";\n\t}\n};\n/**\n* Returns `true` if fiber is a composite fiber. Composite fibers are fibers that can render (like functional components, class components, etc.)\n*\n* @see https://reactnative.dev/architecture/glossary#react-composite-components\n*/\nconst isCompositeFiber = (fiber) => {\n\tswitch (fiber.tag) {\n\t\tcase FunctionComponentTag:\n\t\tcase ClassComponentTag:\n\t\tcase SimpleMemoComponentTag:\n\t\tcase MemoComponentTag:\n\t\tcase ForwardRefTag: return true;\n\t\tdefault: return false;\n\t}\n};\n/**\n* Returns `true` if the two {@link Fiber}s are the same reference\n*/\nconst areFiberEqual = (fiberA, fiberB) => {\n\treturn fiberA === fiberB || fiberA.alternate === fiberB || fiberB.alternate === fiberA;\n};\n/**\n* Traverses up or down a {@link Fiber}'s contexts, return `true` to stop and select the current and previous context value.\n*/\nconst traverseContexts = (fiber, selector) => {\n\ttry {\n\t\tconst nextDependencies = fiber.dependencies;\n\t\tconst prevDependencies = fiber.alternate?.dependencies;\n\t\tif (!nextDependencies || !prevDependencies) return false;\n\t\tif (typeof nextDependencies !== \"object\" || !(\"firstContext\" in nextDependencies) || typeof prevDependencies !== \"object\" || !(\"firstContext\" in prevDependencies)) return false;\n\t\tlet nextContext = nextDependencies.firstContext;\n\t\tlet prevContext = prevDependencies.firstContext;\n\t\twhile (nextContext && typeof nextContext === \"object\" && \"memoizedValue\" in nextContext || prevContext && typeof prevContext === \"object\" && \"memoizedValue\" in prevContext) {\n\t\t\tif (selector(nextContext, prevContext) === true) return true;\n\t\t\tnextContext = nextContext?.next;\n\t\t\tprevContext = prevContext?.next;\n\t\t}\n\t} catch {}\n\treturn false;\n};\n/**\n* Traverses up or down a {@link Fiber}'s states, return `true` to stop and select the current and previous state value. This stores both state values and effects.\n*/\nconst traverseState = (fiber, selector) => {\n\ttry {\n\t\tlet nextState = fiber.memoizedState;\n\t\tlet prevState = fiber.alternate?.memoizedState;\n\t\twhile (nextState || prevState) {\n\t\t\tif (selector(nextState, prevState) === true) return true;\n\t\t\tnextState = nextState?.next;\n\t\t\tprevState = prevState?.next;\n\t\t}\n\t} catch {}\n\treturn false;\n};\n/**\n* Traverses up or down a {@link Fiber}'s props, return `true` to stop and select the current and previous props value.\n*/\nconst traverseProps = (fiber, selector) => {\n\ttry {\n\t\tconst nextProps = fiber.memoizedProps;\n\t\tconst prevProps = fiber.alternate?.memoizedProps || {};\n\t\tconst allKeys = new Set([...Object.keys(prevProps), ...Object.keys(nextProps)]);\n\t\tfor (const propName of allKeys) {\n\t\t\tconst prevValue = prevProps?.[propName];\n\t\t\tconst nextValue = nextProps?.[propName];\n\t\t\tif (selector(propName, nextValue, prevValue) === true) return true;\n\t\t}\n\t} catch {}\n\treturn false;\n};\n/**\n* Returns `true` if the {@link Fiber} has rendered. Note that this does not mean the fiber has rendered in the current commit, just that it has rendered in the past.\n*/\nconst didFiberRender = (fiber) => {\n\tconst nextProps = fiber.memoizedProps;\n\tconst prevProps = fiber.alternate?.memoizedProps || {};\n\tconst flags = fiber.flags ?? fiber.effectTag ?? 0;\n\tswitch (fiber.tag) {\n\t\tcase ClassComponentTag:\n\t\tcase FunctionComponentTag:\n\t\tcase ContextConsumerTag:\n\t\tcase ForwardRefTag:\n\t\tcase MemoComponentTag:\n\t\tcase SimpleMemoComponentTag: return (flags & PerformedWork) === PerformedWork;\n\t\tdefault:\n\t\t\tif (!fiber.alternate) return true;\n\t\t\treturn prevProps !== nextProps || fiber.alternate.memoizedState !== fiber.memoizedState || fiber.alternate.ref !== fiber.ref;\n\t}\n};\n/**\n* Returns `true` if the {@link Fiber} has committed. Note that this does not mean the fiber has committed in the current commit, just that it has committed in the past.\n*/\nconst didFiberCommit = (fiber) => {\n\treturn Boolean((fiber.flags & (MutationMask | Cloned)) !== 0 || (fiber.subtreeFlags & (MutationMask | Cloned)) !== 0);\n};\n/**\n* Returns all host {@link Fiber}s that have committed and rendered.\n*/\nconst getMutatedHostFibers = (fiber) => {\n\tconst mutations = [];\n\tconst stack = [fiber];\n\twhile (stack.length) {\n\t\tconst node = stack.pop();\n\t\tif (!node) continue;\n\t\tif (isHostFiber(node) && didFiberCommit(node) && didFiberRender(node)) mutations.push(node);\n\t\tif (node.child) stack.push(node.child);\n\t\tif (node.sibling) stack.push(node.sibling);\n\t}\n\treturn mutations;\n};\n/**\n* Returns the stack of {@link Fiber}s from the current fiber to the root fiber.\n*\n* @example\n* ```ts\n* [fiber, fiber.return, fiber.return.return, ...]\n* ```\n*/\nconst getFiberStack = (fiber) => {\n\tconst stack = [];\n\tlet currentFiber = fiber;\n\twhile (currentFiber.return) {\n\t\tstack.push(currentFiber);\n\t\tcurrentFiber = currentFiber.return;\n\t}\n\treturn stack;\n};\n/**\n* Returns `true` if the {@link Fiber} should be filtered out during reconciliation.\n*/\nconst shouldFilterFiber = (fiber) => {\n\tswitch (fiber.tag) {\n\t\tcase DehydratedSuspenseComponentTag: return true;\n\t\tcase HostTextTag:\n\t\tcase FragmentTag:\n\t\tcase LegacyHiddenComponentTag:\n\t\tcase OffscreenComponentTag: return true;\n\t\tcase HostRootTag: return false;\n\t\tdefault: {\n\t\t\tconst symbolOrNumber = typeof fiber.type === \"object\" && fiber.type !== null ? fiber.type.$$typeof : fiber.type;\n\t\t\tconst typeSymbol = typeof symbolOrNumber === \"symbol\" ? symbolOrNumber.toString() : symbolOrNumber;\n\t\t\tswitch (typeSymbol) {\n\t\t\t\tcase CONCURRENT_MODE_NUMBER:\n\t\t\t\tcase CONCURRENT_MODE_SYMBOL_STRING:\n\t\t\t\tcase DEPRECATED_ASYNC_MODE_SYMBOL_STRING: return true;\n\t\t\t\tdefault: return false;\n\t\t\t}\n\t\t}\n\t}\n};\n/**\n* Returns the nearest host {@link Fiber} to the current {@link Fiber}.\n*/\nconst getNearestHostFiber = (fiber, ascending = false) => {\n\tlet hostFiber = traverseFiber(fiber, isHostFiber, ascending);\n\tif (!hostFiber) hostFiber = traverseFiber(fiber, isHostFiber, !ascending);\n\treturn hostFiber;\n};\n/**\n* Returns all host {@link Fiber}s in the tree that are associated with the current {@link Fiber}.\n*/\nconst getNearestHostFibers = (fiber) => {\n\tconst hostFibers = [];\n\tconst stack = [];\n\tif (isHostFiber(fiber)) hostFibers.push(fiber);\n\telse if (fiber.child) stack.push(fiber.child);\n\twhile (stack.length) {\n\t\tconst currentNode = stack.pop();\n\t\tif (!currentNode) break;\n\t\tif (isHostFiber(currentNode)) hostFibers.push(currentNode);\n\t\telse if (currentNode.child) stack.push(currentNode.child);\n\t\tif (currentNode.sibling) stack.push(currentNode.sibling);\n\t}\n\treturn hostFibers;\n};\nfunction traverseFiber(fiber, selector, ascending = false) {\n\tconst isAsync = fiber && selector(fiber) instanceof Promise;\n\tif (isAsync) return traverseFiberAsync(fiber, selector, ascending);\n\treturn traverseFiberSync(fiber, selector, ascending);\n}\nconst traverseFiberSync = (fiber, selector, ascending = false) => {\n\tif (!fiber) return null;\n\tif (selector(fiber) === true) return fiber;\n\tlet child = ascending ? fiber.return : fiber.child;\n\twhile (child) {\n\t\tconst match = traverseFiberSync(child, selector, ascending);\n\t\tif (match) return match;\n\t\tchild = ascending ? null : child.sibling;\n\t}\n\treturn null;\n};\nconst traverseFiberAsync = async (fiber, selector, ascending = false) => {\n\tif (!fiber) return null;\n\tif (await selector(fiber) === true) return fiber;\n\tlet child = ascending ? fiber.return : fiber.child;\n\twhile (child) {\n\t\tconst match = await traverseFiberAsync(child, selector, ascending);\n\t\tif (match) return match;\n\t\tchild = ascending ? null : child.sibling;\n\t}\n\treturn null;\n};\n/**\n* Returns the timings of the {@link Fiber}.\n*\n* @example\n* ```ts\n* const { selfTime, totalTime } = getTimings(fiber);\n* console.log(selfTime, totalTime);\n* ```\n*/\nconst getTimings = (fiber) => {\n\tconst totalTime = fiber?.actualDuration ?? 0;\n\tlet selfTime = totalTime;\n\tlet child = fiber?.child ?? null;\n\twhile (totalTime > 0 && child != null) {\n\t\tselfTime -= child.actualDuration ?? 0;\n\t\tchild = child.sibling;\n\t}\n\treturn {\n\t\tselfTime,\n\t\ttotalTime\n\t};\n};\n/**\n* Returns `true` if the {@link Fiber} uses React Compiler's memo cache.\n*/\nconst hasMemoCache = (fiber) => {\n\treturn Boolean(fiber.updateQueue?.memoCache);\n};\n/**\n* Returns the type (e.g. component definition) of the {@link Fiber}\n*/\nconst getType = (type) => {\n\tconst currentType = type;\n\tif (typeof currentType === \"function\") return currentType;\n\tif (typeof currentType === \"object\" && currentType) return getType(currentType.type || currentType.render);\n\treturn null;\n};\n/**\n* Returns the display name of the {@link Fiber} type.\n*/\nconst getDisplayName = (type) => {\n\tconst currentType = type;\n\tif (typeof currentType === \"string\") return currentType;\n\tif (typeof currentType !== \"function\" && !(typeof currentType === \"object\" && currentType)) return null;\n\tconst name = currentType.displayName || currentType.name || null;\n\tif (name) return name;\n\tconst unwrappedType = getType(currentType);\n\tif (!unwrappedType) return null;\n\treturn unwrappedType.displayName || unwrappedType.name || null;\n};\n/**\n* Returns the build type of the React renderer.\n*/\nconst detectReactBuildType = (renderer) => {\n\ttry {\n\t\tif (typeof renderer.version === \"string\" && renderer.bundleType > 0) return \"development\";\n\t} catch {}\n\treturn \"production\";\n};\n/**\n* Returns `true` if bippy's instrumentation is active.\n*/\nconst isInstrumentationActive = () => {\n\tconst rdtHook = getRDTHook();\n\treturn Boolean(rdtHook._instrumentationIsActive) || isRealReactDevtools() || isReactRefresh();\n};\n/**\n* Returns the latest fiber (since it may be double-buffered).\n*/\nconst getLatestFiber = (fiber) => {\n\tconst alternate = fiber.alternate;\n\tif (!alternate) return fiber;\n\tif (alternate.actualStartTime && fiber.actualStartTime) return alternate.actualStartTime > fiber.actualStartTime ? alternate : fiber;\n\tfor (const root of _fiberRoots) {\n\t\tconst latestFiber = traverseFiber(root.current, (innerFiber) => {\n\t\t\tif (innerFiber === fiber) return true;\n\t\t});\n\t\tif (latestFiber) return latestFiber;\n\t}\n\treturn fiber;\n};\nlet fiberId = 0;\nconst fiberIdMap = new WeakMap();\nconst setFiberId = (fiber, id = fiberId++) => {\n\tfiberIdMap.set(fiber, id);\n};\nconst getFiberId = (fiber) => {\n\tlet id = fiberIdMap.get(fiber);\n\tif (!id && fiber.alternate) id = fiberIdMap.get(fiber.alternate);\n\tif (!id) {\n\t\tid = fiberId++;\n\t\tsetFiberId(fiber, id);\n\t}\n\treturn id;\n};\nconst mountFiberRecursively = (onRender, firstChild, traverseSiblings) => {\n\tlet fiber = firstChild;\n\twhile (fiber != null) {\n\t\tif (!fiberIdMap.has(fiber)) getFiberId(fiber);\n\t\tconst shouldIncludeInTree = !shouldFilterFiber(fiber);\n\t\tif (shouldIncludeInTree && didFiberRender(fiber)) onRender(fiber, \"mount\");\n\t\tif (fiber.tag === SuspenseComponentTag) {\n\t\t\tconst isTimedOut = fiber.memoizedState !== null;\n\t\t\tif (isTimedOut) {\n\t\t\t\tconst primaryChildFragment = fiber.child;\n\t\t\t\tconst fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;\n\t\t\t\tif (fallbackChildFragment) {\n\t\t\t\t\tconst fallbackChild = fallbackChildFragment.child;\n\t\t\t\t\tif (fallbackChild !== null) mountFiberRecursively(onRender, fallbackChild, false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet primaryChild = null;\n\t\t\t\tconst areSuspenseChildrenConditionallyWrapped = OffscreenComponentTag === -1;\n\t\t\t\tif (areSuspenseChildrenConditionallyWrapped) primaryChild = fiber.child;\n\t\t\t\telse if (fiber.child !== null) primaryChild = fiber.child.child;\n\t\t\t\tif (primaryChild !== null) mountFiberRecursively(onRender, primaryChild, false);\n\t\t\t}\n\t\t} else if (fiber.child != null) mountFiberRecursively(onRender, fiber.child, true);\n\t\tfiber = traverseSiblings ? fiber.sibling : null;\n\t}\n};\nconst updateFiberRecursively = (onRender, nextFiber, prevFiber, parentFiber) => {\n\tif (!fiberIdMap.has(nextFiber)) getFiberId(nextFiber);\n\tif (!prevFiber) return;\n\tif (!fiberIdMap.has(prevFiber)) getFiberId(prevFiber);\n\tconst isSuspense = nextFiber.tag === SuspenseComponentTag;\n\tconst shouldIncludeInTree = !shouldFilterFiber(nextFiber);\n\tif (shouldIncludeInTree && didFiberRender(nextFiber)) onRender(nextFiber, \"update\");\n\tconst prevDidTimeout = isSuspense && prevFiber.memoizedState !== null;\n\tconst nextDidTimeOut = isSuspense && nextFiber.memoizedState !== null;\n\tif (prevDidTimeout && nextDidTimeOut) {\n\t\tconst nextFallbackChildSet = nextFiber.child?.sibling ?? null;\n\t\tconst prevFallbackChildSet = prevFiber.child?.sibling ?? null;\n\t\tif (nextFallbackChildSet !== null && prevFallbackChildSet !== null) updateFiberRecursively(onRender, nextFallbackChildSet, prevFallbackChildSet, nextFiber);\n\t} else if (prevDidTimeout && !nextDidTimeOut) {\n\t\tconst nextPrimaryChildSet = nextFiber.child;\n\t\tif (nextPrimaryChildSet !== null) mountFiberRecursively(onRender, nextPrimaryChildSet, true);\n\t} else if (!prevDidTimeout && nextDidTimeOut) {\n\t\tunmountFiberChildrenRecursively(onRender, prevFiber);\n\t\tconst nextFallbackChildSet = nextFiber.child?.sibling ?? null;\n\t\tif (nextFallbackChildSet !== null) mountFiberRecursively(onRender, nextFallbackChildSet, true);\n\t} else if (nextFiber.child !== prevFiber.child) {\n\t\tlet nextChild = nextFiber.child;\n\t\twhile (nextChild) {\n\t\t\tif (nextChild.alternate) {\n\t\t\t\tconst prevChild = nextChild.alternate;\n\t\t\t\tupdateFiberRecursively(onRender, nextChild, prevChild, shouldIncludeInTree ? nextFiber : parentFiber);\n\t\t\t} else mountFiberRecursively(onRender, nextChild, false);\n\t\t\tnextChild = nextChild.sibling;\n\t\t}\n\t}\n};\nconst unmountFiber = (onRender, fiber) => {\n\tconst isRoot = fiber.tag === HostRootTag;\n\tif (isRoot || !shouldFilterFiber(fiber)) onRender(fiber, \"unmount\");\n};\nconst unmountFiberChildrenRecursively = (onRender, fiber) => {\n\tconst isTimedOutSuspense = fiber.tag === SuspenseComponentTag && fiber.memoizedState !== null;\n\tlet child = fiber.child;\n\tif (isTimedOutSuspense) {\n\t\tconst primaryChildFragment = fiber.child;\n\t\tconst fallbackChildFragment = primaryChildFragment?.sibling ?? null;\n\t\tchild = fallbackChildFragment?.child ?? null;\n\t}\n\twhile (child !== null) {\n\t\tif (child.return !== null) {\n\t\t\tunmountFiber(onRender, child);\n\t\t\tunmountFiberChildrenRecursively(onRender, child);\n\t\t}\n\t\tchild = child.sibling;\n\t}\n};\nlet commitId = 0;\nconst rootInstanceMap = new WeakMap();\n/**\n* Creates a fiber visitor function. Must pass a fiber root and a render handler.\n* @example\n* traverseRenderedFibers(root, (fiber, phase) => {\n*   console.log(phase)\n* })\n*/\nconst traverseRenderedFibers = (root, onRender) => {\n\tconst fiber = \"current\" in root ? root.current : root;\n\tlet rootInstance = rootInstanceMap.get(root);\n\tif (!rootInstance) {\n\t\trootInstance = {\n\t\t\tprevFiber: null,\n\t\t\tid: commitId++\n\t\t};\n\t\trootInstanceMap.set(root, rootInstance);\n\t}\n\tconst { prevFiber } = rootInstance;\n\tif (!fiber) unmountFiber(onRender, fiber);\n\telse if (prevFiber !== null) {\n\t\tconst wasMounted = prevFiber && prevFiber.memoizedState != null && prevFiber.memoizedState.element != null && prevFiber.memoizedState.isDehydrated !== true;\n\t\tconst isMounted = fiber.memoizedState != null && fiber.memoizedState.element != null && fiber.memoizedState.isDehydrated !== true;\n\t\tif (!wasMounted && isMounted) mountFiberRecursively(onRender, fiber, false);\n\t\telse if (wasMounted && isMounted) updateFiberRecursively(onRender, fiber, fiber.alternate, null);\n\t\telse if (wasMounted && !isMounted) unmountFiber(onRender, fiber);\n\t} else mountFiberRecursively(onRender, fiber, true);\n\trootInstance.prevFiber = fiber;\n};\n/**\n* @deprecated use `traverseRenderedFibers` instead\n*/\nconst createFiberVisitor = ({ onRender }) => {\n\treturn (_rendererID, root, _state) => {\n\t\ttraverseRenderedFibers(root, onRender);\n\t};\n};\nlet _overrideProps = null;\nlet _overrideHookState = null;\nlet _overrideContext = null;\nconst injectOverrideMethods = () => {\n\tif (!hasRDTHook()) return null;\n\tconst rdtHook = getRDTHook();\n\tif (!rdtHook?.renderers) return null;\n\tif (_overrideProps || _overrideHookState || _overrideContext) return {\n\t\toverrideProps: _overrideProps,\n\t\toverrideHookState: _overrideHookState,\n\t\toverrideContext: _overrideContext\n\t};\n\tfor (const [_, renderer] of Array.from(rdtHook.renderers)) try {\n\t\tif (_overrideHookState) {\n\t\t\tconst prevOverrideHookState = _overrideHookState;\n\t\t\t_overrideHookState = (fiber, id, path, value) => {\n\t\t\t\tlet current = fiber.memoizedState;\n\t\t\t\tfor (let i = 0; i < Number(id); i++) {\n\t\t\t\t\tif (!current?.next) break;\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t}\n\t\t\t\tif (current?.queue) {\n\t\t\t\t\tconst queue = current.queue;\n\t\t\t\t\tif (isPOJO(queue) && \"dispatch\" in queue) {\n\t\t\t\t\t\tconst dispatch = queue.dispatch;\n\t\t\t\t\t\tdispatch(value);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprevOverrideHookState(fiber, id, path, value);\n\t\t\t\trenderer.overrideHookState?.(fiber, id, path, value);\n\t\t\t};\n\t\t} else if (renderer.overrideHookState) _overrideHookState = renderer.overrideHookState;\n\t\tif (_overrideProps) {\n\t\t\tconst prevOverrideProps = _overrideProps;\n\t\t\t_overrideProps = (fiber, path, value) => {\n\t\t\t\tprevOverrideProps(fiber, path, value);\n\t\t\t\trenderer.overrideProps?.(fiber, path, value);\n\t\t\t};\n\t\t} else if (renderer.overrideProps) _overrideProps = renderer.overrideProps;\n\t\t_overrideContext = (fiber, contextType, path, value) => {\n\t\t\tlet current = fiber;\n\t\t\twhile (current) {\n\t\t\t\tconst type = current.type;\n\t\t\t\tif (type === contextType || type?.Provider === contextType) {\n\t\t\t\t\tif (_overrideProps) {\n\t\t\t\t\t\t_overrideProps(current, [\"value\", ...path], value);\n\t\t\t\t\t\tif (current.alternate) _overrideProps(current.alternate, [\"value\", ...path], value);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcurrent = current.return;\n\t\t\t}\n\t\t};\n\t} catch {}\n};\nconst isPOJO = (maybePOJO) => {\n\treturn Object.prototype.toString.call(maybePOJO) === \"[object Object]\" && (Object.getPrototypeOf(maybePOJO) === Object.prototype || Object.getPrototypeOf(maybePOJO) === null);\n};\nconst buildPathsFromValue = (maybePOJO, basePath = []) => {\n\tif (!isPOJO(maybePOJO)) return [{\n\t\tpath: basePath,\n\t\tvalue: maybePOJO\n\t}];\n\tconst paths = [];\n\tfor (const key in maybePOJO) {\n\t\tconst value = maybePOJO[key];\n\t\tconst path = basePath.concat(key);\n\t\tif (isPOJO(value)) paths.push(...buildPathsFromValue(value, path));\n\t\telse paths.push({\n\t\t\tpath,\n\t\t\tvalue\n\t\t});\n\t}\n\treturn paths;\n};\nconst overrideProps = (fiber, partialValue) => {\n\tinjectOverrideMethods();\n\tconst paths = buildPathsFromValue(partialValue);\n\tfor (const { path, value } of paths) try {\n\t\t_overrideProps?.(fiber, path, value);\n\t} catch {}\n};\nconst overrideHookState = (fiber, id, partialValue) => {\n\tinjectOverrideMethods();\n\tconst hookId = String(id);\n\tif (isPOJO(partialValue)) {\n\t\tconst paths = buildPathsFromValue(partialValue);\n\t\tfor (const { path, value } of paths) try {\n\t\t\t_overrideHookState?.(fiber, hookId, path, value);\n\t\t} catch {}\n\t} else try {\n\t\t_overrideHookState?.(fiber, hookId, [], partialValue);\n\t} catch {}\n};\nconst overrideContext = (fiber, contextType, partialValue) => {\n\tinjectOverrideMethods();\n\tif (isPOJO(partialValue)) {\n\t\tconst paths = buildPathsFromValue(partialValue);\n\t\tfor (const { path, value } of paths) try {\n\t\t\t_overrideContext?.(fiber, contextType, path, value);\n\t\t} catch {}\n\t} else try {\n\t\t_overrideContext?.(fiber, contextType, [], partialValue);\n\t} catch {}\n};\n/**\n* Instruments the DevTools hook.\n* @example\n* const hook = instrument({\n*   onActive() {\n*     console.log('initialized');\n*   },\n*   onCommitFiberRoot(rendererID, root) {\n*     console.log('fiberRoot', root.current)\n*   },\n* });\n*/\nconst instrument = (options) => {\n\treturn getRDTHook(() => {\n\t\tconst rdtHook = getRDTHook();\n\t\toptions.onActive?.();\n\t\trdtHook._instrumentationSource = options.name ?? BIPPY_INSTRUMENTATION_STRING;\n\t\tconst prevOnCommitFiberRoot = rdtHook.onCommitFiberRoot;\n\t\tif (options.onCommitFiberRoot) rdtHook.onCommitFiberRoot = (rendererID, root, priority) => {\n\t\t\tif (prevOnCommitFiberRoot) prevOnCommitFiberRoot(rendererID, root, priority);\n\t\t\toptions.onCommitFiberRoot?.(rendererID, root, priority);\n\t\t};\n\t\tconst prevOnCommitFiberUnmount = rdtHook.onCommitFiberUnmount;\n\t\tif (options.onCommitFiberUnmount) rdtHook.onCommitFiberUnmount = (rendererID, root) => {\n\t\t\tif (prevOnCommitFiberUnmount) prevOnCommitFiberUnmount(rendererID, root);\n\t\t\toptions.onCommitFiberUnmount?.(rendererID, root);\n\t\t};\n\t\tconst prevOnPostCommitFiberRoot = rdtHook.onPostCommitFiberRoot;\n\t\tif (options.onPostCommitFiberRoot) rdtHook.onPostCommitFiberRoot = (rendererID, root) => {\n\t\t\tif (prevOnPostCommitFiberRoot) prevOnPostCommitFiberRoot(rendererID, root);\n\t\t\toptions.onPostCommitFiberRoot?.(rendererID, root);\n\t\t};\n\t});\n};\nconst getFiberFromHostInstance = (hostInstance) => {\n\tconst rdtHook = getRDTHook();\n\tfor (const renderer of rdtHook.renderers.values()) try {\n\t\tconst fiber = renderer.findFiberByHostInstance?.(hostInstance);\n\t\tif (fiber) return fiber;\n\t} catch {}\n\tif (typeof hostInstance === \"object\" && hostInstance != null) {\n\t\tif (\"_reactRootContainer\" in hostInstance) return hostInstance._reactRootContainer?._internalRoot?.current?.child;\n\t\tfor (const key in hostInstance) if (key.startsWith(\"__reactContainer$\") || key.startsWith(\"__reactInternalInstance$\") || key.startsWith(\"__reactFiber\")) return hostInstance[key] || null;\n\t}\n\treturn null;\n};\nconst INSTALL_ERROR = new Error();\nconst _fiberRoots = new Set();\nconst secure = (options, secureOptions = {}) => {\n\tconst onActive = options.onActive;\n\tconst isRDTHookInstalled = hasRDTHook();\n\tconst isUsingRealReactDevtools = isRealReactDevtools();\n\tconst isUsingReactRefresh = isReactRefresh();\n\tlet timeout;\n\tlet isDevelopment = !secureOptions.isProduction;\n\toptions.onActive = () => {\n\t\tclearTimeout(timeout);\n\t\tlet isSecure = true;\n\t\ttry {\n\t\t\tconst rdtHook = getRDTHook();\n\t\t\tfor (const renderer of rdtHook.renderers.values()) {\n\t\t\t\tconst [majorVersion] = renderer.version.split(\".\");\n\t\t\t\tif (Number(majorVersion) < (secureOptions.minReactMajorVersion ?? 17)) isSecure = false;\n\t\t\t\tconst buildType = detectReactBuildType(renderer);\n\t\t\t\tif (buildType === \"development\") isDevelopment = true;\n\t\t\t\telse if (!secureOptions.dangerouslyRunInProduction) isSecure = false;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tsecureOptions.onError?.(err);\n\t\t}\n\t\tif (!isSecure) {\n\t\t\toptions.onCommitFiberRoot = void 0;\n\t\t\toptions.onCommitFiberUnmount = void 0;\n\t\t\toptions.onPostCommitFiberRoot = void 0;\n\t\t\toptions.onActive = void 0;\n\t\t\treturn;\n\t\t}\n\t\tonActive?.();\n\t\ttry {\n\t\t\tconst onCommitFiberRoot$1 = options.onCommitFiberRoot;\n\t\t\tif (onCommitFiberRoot$1) options.onCommitFiberRoot = (rendererID, root, priority) => {\n\t\t\t\tif (!_fiberRoots.has(root)) _fiberRoots.add(root);\n\t\t\t\ttry {\n\t\t\t\t\tonCommitFiberRoot$1(rendererID, root, priority);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tsecureOptions.onError?.(err);\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst onCommitFiberUnmount = options.onCommitFiberUnmount;\n\t\t\tif (onCommitFiberUnmount) options.onCommitFiberUnmount = (rendererID, root) => {\n\t\t\t\ttry {\n\t\t\t\t\tonCommitFiberUnmount(rendererID, root);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tsecureOptions.onError?.(err);\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst onPostCommitFiberRoot = options.onPostCommitFiberRoot;\n\t\t\tif (onPostCommitFiberRoot) options.onPostCommitFiberRoot = (rendererID, root) => {\n\t\t\t\ttry {\n\t\t\t\t\tonPostCommitFiberRoot(rendererID, root);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tsecureOptions.onError?.(err);\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tsecureOptions.onError?.(err);\n\t\t}\n\t};\n\tif (!isRDTHookInstalled && !isUsingRealReactDevtools && !isUsingReactRefresh) timeout = setTimeout(() => {\n\t\tif (isDevelopment) secureOptions.onError?.(INSTALL_ERROR);\n\t\tstop();\n\t}, secureOptions.installCheckTimeout ?? 100);\n\treturn options;\n};\n/**\n* a wrapper around the {@link instrument} function that sets the `onCommitFiberRoot` hook.\n*\n* @example\n* onCommitFiberRoot((root) => {\n*   console.log(root.current);\n* });\n*/\nconst onCommitFiberRoot = (handler) => {\n\treturn instrument(secure({ onCommitFiberRoot: (_, root) => {\n\t\thandler(root);\n\t} }));\n};\n\n//#endregion\n//#region src/index.ts\nsafelyInstallRDTHook();\n\n//#endregion\nexport { ActivityComponentTag, BIPPY_INSTRUMENTATION_STRING, CONCURRENT_MODE_NUMBER, CONCURRENT_MODE_SYMBOL_STRING, ClassComponentTag, ContextConsumerTag, DEPRECATED_ASYNC_MODE_SYMBOL_STRING, DehydratedSuspenseComponentTag, ELEMENT_TYPE_SYMBOL_STRING, ForwardRefTag, FragmentTag, FunctionComponentTag, HostComponentTag, HostHoistableTag, HostRootTag, HostSingletonTag, HostTextTag, INSTALL_ERROR, LazyComponentTag, LegacyHiddenComponentTag, MemoComponentTag, OffscreenComponentTag, SimpleMemoComponentTag, SuspenseComponentTag, SuspenseListComponentTag, TRANSITIONAL_ELEMENT_TYPE_SYMBOL_STRING, ViewTransitionComponentTag, _fiberRoots, _renderers, areFiberEqual, createFiberVisitor, detectReactBuildType, didFiberCommit, didFiberRender, fiberIdMap, getDisplayName, getFiberFromHostInstance, getFiberId, getFiberStack, getLatestFiber, getMutatedHostFibers, getNearestHostFiber, getNearestHostFibers, getRDTHook, getTimings, getType, hasMemoCache, hasRDTHook, injectOverrideMethods, installRDTHook, instrument, isClientEnvironment, isCompositeFiber, isHostFiber, isInstrumentationActive, isReactRefresh, isRealReactDevtools, isValidElement, isValidFiber, mountFiberRecursively, onCommitFiberRoot, overrideContext, overrideHookState, overrideProps, patchRDTHook, safelyInstallRDTHook, secure, setFiberId, shouldFilterFiber, traverseContexts, traverseFiber, traverseFiberAsync, traverseFiberSync, traverseProps, traverseRenderedFibers, traverseState, unmountFiber, unmountFiberChildrenRecursively, updateFiberRecursively, version };","import 'bippy';\nexport * from 'react/jsx-runtime';\n"],"names":[],"mappings":"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","ignoreList":[0,1]}